\documentclass[twoside, 12pt]{epstfg}


\usepackage{lipsum}
\usepackage[numbers]{natbib}
\usepackage{fancysprefs}
\usepackage{booktabs}
\usepackage{wrapfig}
\usepackage{enumitem}
\usepackage{xfrac}
\usepackage{multirow}

\usepackage{tikz}

\usetikzlibrary{arrows}
\usetikzlibrary{patterns}
\usetikzlibrary{intersections}
\usetikzlibrary{calc}
\usetikzlibrary{fadings}

\definecolor{palette1}{HTML}{1B9E77}
\definecolor{palette2}{HTML}{D95F02}
\definecolor{palette3}{HTML}{7570B3}
\definecolor{palette4}{HTML}{E7298A}
\definecolor{palette5}{HTML}{66A61E}
\definecolor{palette6}{HTML}{E6AB02}
\definecolor{palette7}{HTML}{A6761D}
\definecolor{palette8}{HTML}{666666}

\tikzstyle{vnlin}=[rectangle, inner sep=0pt, minimum height=6pt, minimum width=0pt, draw, fill=black]
\tikzstyle{hnlin}=[rectangle, inner sep=0pt, minimum height=0pt, minimum width=6pt, draw, fill=black]
\tikzset{>=latex}

\bibliographystyle{abbrv}

\title[spa]{Reconstrucción de caminos}
\title[eng]{Path reconstruction}
\author{David Moreno Maldonado}
\tutor{Guillermo Julián Moreno}
\date[spa]{Mayo 2020}
\date[eng]{May 2020}
\group[spa]{Naudit}
\group[eng]{Naudit}
\department[spa]{Tecnología Electrónica y de las comunicaciones}
\department[eng]{Department}

\setdegreeDouble

%Resumen
%Abstract (resumen en ingles)

%Glosario

\begin{document}

\selectlanguage{spanish}

\frontmatter

\maketitle[spa]
% \maketitle[eng]

\makeinnertitle[spa]
% \makeinnertitle[eng]

%\makeabstract[spa]
%\makeabstract[eng]

\tableofcontents
\clearpage
\listoftables
\clearpage
\listoffigures
\cleardoublepage

\printnoidxglossaries

\mainmatter

\chapter{Introducción y motivación}
%todo

\section{Motivación}
%todo

\section{Objetivos}
%todo

\section{Estructura del documento}
%todo

\chapter{Estado del arte}
%todo

\chapter{Desarrollo e implementación}
\label{chap:Desarrollo}
\section{Decisiones generales de desarrollo}
%%todo: Expandir el sentido de porque se realizo la modularizacion
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%todo: Reorganizar parrafos%%%%%%%%%%%%
En un comienzo se pensó que con el análisis de trazas pcap sería suficiente. Sin embargo, se consideró que sería útil que fuera posible realizar el análisis de superflujos a partir de otros ficheros de origen. El ejemplo más claro fue el de la salida de 'Procesa' un programa que lee y extrae información del tráfico de red y la presenta como registros por flujo. En este momento fue cuando la estructura y la relacion entre los diferentes módulos cobró forma y sentido. 

El análisis de tráfico se realiza mediante un módulo escrito en C. El módulo forma parte de un programa más grande llamado fisher. Dicha aplicación se centraba en el análisis de trazas pcap mediante la definición de funciones que se encargan de la inicialización, preprocesado, análisis, postprocesado y salida de los registros de la traza pcap. Se han utilizado y modificado varias de las librerias de este programa, haciendose uso de facilidades como el log, utilidades para estructuras ip y mac o el gestor de memoria para generar pools de memoria.

El desarrollo del módulo completo de análisis de superflujos ha supuesto para fisher un aprovechamiento de su potencial y una ampliación de su funcionalidad. Como se ha especificado, fisher es un programa centrado en el procesamiento de trazas pcap; fue por esto que se considero la implementación del analizador de superflujos como una parte de este programa. Más adelante, se añadieron nuevas funcionalidades acordes a las necesidades específicas del proyecto, como fue el análisis de la salida de Procesa además de la de trazas pcap

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Librerias usadas pertenecientes a fisher}
Durante el desarrollo del módulo de análisis de superflujos se aprovecho el código ya escrito de fisher y la estructura interna del programa para facilitar el manejo de estructuras, el análisis de fallos y las pruebas de código. Las librerias de las que se hizo uso directo se enumeran a continuación y se describe el uso que se dio de cada una:
\subsection{Types y errors}
Librerias básicas para la definición de macros que se usaron para que el módulo implementado fuera coherente con el resto del programa.
\subsection{Log} 
Libreria para el manejo de la información de flujo del programa con diferentes niveles de profundidad que se podian seleccionar al ejecutar. Útil para distinguir en el log entre errores más graves y consideraciones solo usadas para la depuración de código.
\subsection{Static mem}
Libreria para la gesión de la memoria estática. Evitar el uso de reservas de memoria continuamente fue uno de los requisitos exigidos para el desarrollo del módulo. Se consideró que la gestión dinámica de memoria mediante las funciones estandar de C (malloc y free) era muy lenta dado la cantidad de estas reservas que habria que hacer. Es por esto que la gestión se dejo a una libreria ya desarrollada. 

Conceptualmente lo que se realiza es solo una reserva de memoria mediante la función malloc en la que, mediante la libreria 'static mem', se definía la cantidad total de entidades de un mismo tipo de estructura se van a reservar a lo largo de la ejecución del programa. Esto conlleva realizar un 'pool' diferente para cada tipo de estructura, pero resulta en una mejora en la eficiencia general del programa. 
%todo: Meter referencia para analizar mas detenidamente el uso de high performance y el rechazo de los mallocs, ademas de como se gestiona la memoria total que se le quiere dedicar al programa para realizar la reserva de memoria
\subsection{IP y MAC utils}
Estas librerias ya existentes fueron modificadas incluyendo nuevas funciones que eran necesarias para el uso de la libreria de lista de capas que se desarrolló. Las funciones incluidas eran comparadores, copiadores y conversores a cadenas de carácteres con una estructura definida. Estas funciones son las que se pasaban como punteros para que la libreria desarrollada fuera lo mas abstracta posible.
\subsection{Packet parser}
Libreria con las funciones necesarias para leer la información del paquete a nivel de byte y pasarla a una estructura manejable por el programa. También se amplió la funcionalidad de esta libreria introduciendo la extracción de la información a nivel MAC y la extracción de las opciones dentro de la capa TCP.
\subsection{Tests}
Fisher contaba con un sistema de tests para el código desarrollado totalmente automatizado en el Makefile. Se hizo uso de esta posibilidad para tener tests unitarios que aseguraran el funcionamiento básico de la librería principal de lista por capas. Esto hizo que se pudiera comprobar con mucha facilidad el funcionamiento correcto del programa, así como localizar los errores con mayor facilidad.
%todo: Hablar sobre el CI


\section{Módulo de ordenación de superflujos}

%%todo: Descripcion general del módulo
Este módulo encargará de la inserción de nuevos elementos a los superflujos, manteniendo el orden, respetando la información perteneciente a cada capa (MAC o IP) y actualizando la información tanto de nodos como de aristas. Además, tendrá en cuenta los atributos de orden que se le indiquen para inferir el lugar de los nodos que no puedan ser reconocidos directamente. Guarda también información de nodos que no se puedan insertar por sus características, para que en otro momento de la ejecución se puedan volver a intentar insertar.

\subsection{Estructura de datos usada}
A un nivel abstracto, este módulo representa un grafo orientado con un único nodo inicial y un único nodo final. Cada nodo puede pertenecer a una de las capas que se indican al inicializar la estructura y puede comunicarse con nodos de su misma capa o de las adyacentes. En el caso de superflujos las capas serán IP y MAC. Para la implementación de este módulo se han creado 5 estructuras que se relacionan entre ellas. Se describen a continuación:

\begin{itemize}
    \item Lista: Es la estructura general donde se almacena la información de la lista. En su inicialización se debe indicar: los \textit{pools} de memoria para los nodos y las aristas, la información de cada capa, su orden y el número de estas, el número de atributos de orden y las funciones para actualizarlos y usarlos para ordenar nodos y la función que pasa de la estructura de donde se sacará la información de cada camino a la estructura de camino en sí. Una vez definida e inicializada una estructura de lista de capas, se puede insertar caminos estandarizados con la función antes mencionada (\textit{parse\_to\_path}) simplemente llamando a la función de añadir caminos.
    Aparte de esto guarda información sobre los caminos huérfanos y el inicio del grafo.
    (\textit{layer\_list\_add\_path}).
    \item Información de capa: Se guarda la información relacionada con cada capa. Así, cada nodo únicamente tiene un puntero a la información y a la estructura de información de su capa. La información que se almacena es: funciones para comparar, copiar y pasar a cadena de caracteres elementos de la capa, así como el \textit{pool} de memoria.
    \item Nodos de la lista: Se almacena información sobre el elemento, los atributos de orden de ese nodo y las siguientes aristas que conectan este nodo con el resto del grafo.
    \item Aristas: Guardan la información de las aristas (vlans, paquetes, bytes, rtt) que se va actualizando al añadir nuevos caminos y el tipo de conexión que establece entre nodos (real, virtual o cambio de capa).
    \item Caminos: Esta estructura es el enlace entre estructuras exteriores al módulo y las que pertenecen. Es necesaria para mantener la cohesión y funcionamiento del resto de funcionalidades. Como se ha indicado antes, se debe de indicar una función que rellene la información necesaria de esta estructura en función de los datos que se consideren convenientes.
\end{itemize}

%todo
%\begin{enumerate}[itemsep=0pt, topsep = 0pt]
%\item Nodos y aristas para la lista. 
%\item Información de la capa para las funciones de cada capa (punteros a funciones).
%\item Caminos para tener una estructura que comunica con el exterior y que sea la que se inserta
%\item Estructura general para la lista por capas.
%\end{enumerate}

\subsection{Algoritmo para ordenar cada camino del superflujo}
El grafo ordenado representa los diferentes caminos que puede seguir un paquete para llegar desde el nodo de inicio hasta el nodo final. Dependiendo de la red, el número de capas y la longitud de los caminos vistos la complejidad de estos grafos puede variar. En el caso más general intervendrán únicamente dos capas (IP y MAC) y la longitud de los caminos es de 4 (Nodo IP -> Nodo MAC -> Nodo MAC -> Nodo IP). Asumiendo esto nos esrvirá de ejemplo para la explicación del algoritmo de inserción y ordenación de caminos.

Partimos de una lista por capas inicializada, en la que aún no se han insertado caminos. Por cada información de camino que nos llegue, se llamará a la función \textit{parse\_to\_path} para pasar a una estructura estándar que entienda la función \textit{layer\_list\_add\_path}. Una vez dentro de esta función, miramos que nodos del nuevo camino se encuentran en el grafo. Cobran especial relevancia el último nodo del nuevo camino que ya esté en el grafo antes de encontrar un nodo que no esta en el grafo y el primer nodo del nuevo camino que ya está en el grafo después de encontrar nodos  que no están en el grafo. Entre estos dos se encontrará la información nueva que podemos introducir en el grafo.

Tenemos cuatro escenarios en función de los valores de estas dos variables:
\begin{itemize}
    \item Si todos los nodos del nuevo camino ya se encontraban en el grafo tenemos un CAMINO REPETIDO. En este caso actualizamos la información de los nodos y aristas repetidos.
    \item Si los únicos nodos del nuevo camino que se encuentran en el grafo son el primero y el último, entonces tenemos un CAMINO HUÉRFANO. En este caso intentamos ordenarlo en base a los atributos de orden.
    \begin{itemize}
        \item Si conseguimos ordenarlo, lo insertamos en el grafo actualizamos la información de los nodos y aristas repetidas.
        \item Si no se puede ordenar, lo añadimos a la lista de caminos huérfanos.
    \end{itemize}
    \item Si los nodos del nuevo camino que conocemos no son adyacentes en el grafo tenemos una BIFURCACIÓN. Añadimos los nuevos nodos al grafo y actualizamos la información de los nodos y aristas repetidas.
    \item Si no es ninguno de los casos anteriores tenemos una INSERCIÓN NORMAL. Insertamos los nuevos nodos en el grafo y actualizamos la información de los nodos y aristas repetidas.
\end{itemize}
Tras cada inserción exitosa, se realiza una pasada por los caminos huérfanos acumulados para ver si es posible ordenarlos ahora con la nueva información recabada.


\section{Módulo de superflujos IP/MAC}
Este módulo utiliza directamente todas las estructuras y funcionalidades del módulo de ordenación de superflujos. Se realiza de manera abstracta para que se pueda seleccionar la estructura de entrada de donde se sacará la información para los nodos y aristas del grafo ordenado. En este módulo se fijan la inicializacion de las estructuras necesarias para el análisis de superflujos, la adición de nuevos caminos al grafo y la salida que genera el programa. Se comentan los aspectos más relevantes de este módulo.

\subsection{Calculo de coeficientes para la reserva de los 'pools' de memoria}
El programa esta capacitado para usar solo la memoria que se considere necesaria en el momento de la ejecución (por defecto es 32 MB) para las estructuras que se encargan de la ordenación de los superflujos. Como se ha comentado anteriormente, se tiene que definir un pool de memoria diferente para cada estructura y definir cuantas de estas estructuras se van a querer reservar concurrentemente como máximo. Las estructuras para las que es necesario definir un pool de memoria son: superflujos, nodos de grafo, aristas de grafo, elementos IP y elementos MAC. 

\begin{table}[hbtp]
	\centering
	\small
	\begin{tabular}{lcc}
		\toprule \textbf{Estructura} & \textbf{Número de estructuras}  & \textbf{Número de estructuras por superflujo} \\ \midrule
		Superflujos & s & 1 \\
		Elementos IP & i & 2 \\
		Elementos MAC & m & $\alpha$ \\
		Nodos & n & i + m = 2 + $\alpha$ \\
		Aristas & a & $\beta$ = (n - 1)+(n - 2)p \\ \bottomrule
	\end{tabular}
	\caption{Coeficientes de reserva de memoria por cada superflujo}
	\label{tab:Desarrollo:Coeficientes memoria}
\end{table}

La manera de estimar el número de estructuras que reservar de cada tipo se basa en que por cada superflujo podemos estimar la cantidad de los demás elementos que necesitamos en promedio. Esto se traduce en unos coeficientes que se pueden ver en \fref{tab:Desarrollo:Coeficientes memoria}. Es claro que por cada superflujo habra 2 elementos IP (IP origen e IP destino) y que el número de nodos será la suma de los elementos IP y los elementos MAC. Existen los casos especiales de $\alpha$ y $\beta$.

Para estos dos casos se ha recurrido a la observación en casos experimentales. Los parámetros que hay que ajustar son el ratio de MACs que hay por cada superflujo y la probabilidad de que haya una bifurcación. Estos parámetros son variables y se pueden ajustar en función de las características de los datos que se vayan a analizar.
%%Incluir datos para verificar que se cumplen estos coeficientes

Conociendo el tamaño de memoria del que disponemos para nuestras estructuras así como el tamaño de cada una (denotado como $x_{tam}$) podemos conocer cual es la manera óptima de repartir la memoria. Utilizando los superflujos como unidad de memoria (denotada como $u$) podemos obtener la cantidad de unidades de memoria que podemos reservar de esta manera.

$\begin{array}{lcl}
	s \cdot s_{tam} + i \cdot i_{tam} + m \cdot m_{tam} + n \cdot n_{tam} + a \cdot a_{tam} & = & memoria\\
	u \cdot s_{tam} + 2u \cdot i_{tam} + \alpha u \cdot m_{tam} + (2u+\alpha) \cdot n_{tam} + \beta \cdot a_{tam} & = & memoria
\end{array}$

$\begin{array}{lcl}
	u & = & \frac{memoria}{s_{tam} + 2 \cdot i_{tam} + \alpha \cdot m_{tam} + (2u+\alpha) \cdot n_{tam} + \beta \cdot a_{tam}}
\end{array}$

Y de esta manera podemos calcular cuantas estructuras reservar de cada tipo en funcion de la unidad de memoria elegida, que en este caso es el numero de superflujos.

$\begin{cases}
	s = u\\ 
	i = 2u\\ 
	m = \alpha u\\
	n = (2+\alpha)u\\
	a = \beta u
\end{cases}$

\subsection{Diferentes tipos de salida del programa}
%todo

\subsection{Estructura de funciones}
%todo

\subsection{Identificación de los elementos de red}
%todo
\begin{enumerate}[itemsep=0pt, topsep = 0pt]
\item Router NAT
\item Firewall
\item Balanceador de carga
\end{enumerate}

\section{Módulo para entrada por trazas pcap}
%%todo: Descripción general del módulo%%
El módulo para el análisis de trazas pcap tiene una estructura basada en el sistema de punteros a funciones de fisher. En dicho programa se puede hacer un procesado de una trazas únicamente definiendo una serie de funciones. Este módulo, además, utiliza las funciones del módulo de superflujos IP/MAC, por lo que se puede entender como un puente entre la entrada pcap y la estructura más abstracta del análisis IP/MAC. La funcionalidad que se le da a cada una de las funciones que fisher utiliza se describe a continuación:
\begin{itemize}
	\item{Inicialización de variables}
	\item{Preprocesado}
	\item{Análisis de paquete}
	\item{Post-procesado}
	\item{Salida del análisis}
	\item{Distracción de las estructuras}
\end{itemize}

\section{Módulo para entrada por ficheros de 'Procesa'}
%%todo: Descripción general del módulo%%

\chapter{Conclusiones}
%%todo
\label{chap:Conclusiones}

\backmatter
\appendix

\cleardoublepage

\nocite{*}
\bibliography{superflows}{}

\cleardoublepage
\printindex

\end{document}
